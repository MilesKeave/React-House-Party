/*! For license information please see tsparticles.updater.roll.min.js.LICENSE.txt */
!function(e,o){if("object"==typeof exports&&"object"==typeof module)module.exports=o(require("@tsparticles/engine"));else if("function"==typeof define&&define.amd)define(["@tsparticles/engine"],o);else{var l="object"==typeof exports?o(require("@tsparticles/engine")):o(e.window);for(var t in l)("object"==typeof exports?exports:e)[t]=l[t]}}(this,(e=>(()=>{"use strict";var o={533:o=>{o.exports=e}},l={};function t(e){var n=l[e];if(void 0!==n)return n.exports;var a=l[e]={exports:{}};return o[e](a,a.exports,t),a.exports}t.d=(e,o)=>{for(var l in o)t.o(o,l)&&!t.o(e,l)&&Object.defineProperty(e,l,{enumerable:!0,get:o[l]})},t.o=(e,o)=>Object.prototype.hasOwnProperty.call(e,o),t.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};return(()=>{t.r(n),t.d(n,{loadRollUpdater:()=>i});var e=t(533);const o=2*Math.PI;class l{constructor(){this.enable=!1,this.value=0}load(o){o&&(void 0!==o.enable&&(this.enable=o.enable),void 0!==o.value&&(this.value=(0,e.setRangeValue)(o.value)))}}class a{constructor(){this.darken=new l,this.enable=!1,this.enlighten=new l,this.mode="vertical",this.speed=25}load(o){o&&(void 0!==o.backColor&&(this.backColor=e.OptionsColor.create(this.backColor,o.backColor)),this.darken.load(o.darken),void 0!==o.enable&&(this.enable=o.enable),this.enlighten.load(o.enlighten),void 0!==o.mode&&(this.mode=o.mode),void 0!==o.speed&&(this.speed=(0,e.setRangeValue)(o.speed)))}}class r{getTransformValues(e){const o=e.roll?.enable&&e.roll,l=o&&o.horizontal,t=o&&o.vertical;return{a:l?Math.cos(o.angle):void 0,d:t?Math.sin(o.angle):void 0}}init(l){!function(l){const t=l.options.roll;if(t?.enable)if(l.roll={enable:t.enable,horizontal:"horizontal"===t.mode||"both"===t.mode,vertical:"vertical"===t.mode||"both"===t.mode,angle:(0,e.getRandom)()*o,speed:(0,e.getRangeValue)(t.speed)/360},t.backColor)l.backColor=(0,e.rangeColorToHsl)(t.backColor);else if(t.darken.enable&&t.enlighten.enable){const o=(0,e.getRandom)()>=e.halfRandom?"darken":"enlighten";l.roll.alter={type:o,value:(0,e.getRangeValue)("darken"===o?t.darken.value:t.enlighten.value)}}else t.darken.enable?l.roll.alter={type:"darken",value:(0,e.getRangeValue)(t.darken.value)}:t.enlighten.enable&&(l.roll.alter={type:"enlighten",value:(0,e.getRangeValue)(t.enlighten.value)});else l.roll={enable:!1,horizontal:!1,vertical:!1,angle:0,speed:0}}(l)}isEnabled(e){const o=e.options.roll;return!e.destroyed&&!e.spawning&&!!o?.enable}loadOptions(e,...o){e.roll||(e.roll=new a);for(const l of o)e.roll.load(l?.roll)}update(e,l){this.isEnabled(e)&&function(e,l){const t=e.options.roll,n=e.roll;if(!n||!t?.enable)return;const a=n.speed*l.factor,r=o;n.angle+=a,n.angle>r&&(n.angle-=r)}(e,l)}}async function i(e,o=!0){await e.addParticleUpdater("roll",(()=>new r),o)}})(),n})()));